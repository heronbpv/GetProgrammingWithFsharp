#load "Domain.fs"
#load "Operations.fs"

open Capstone3.Operations
open Capstone3.Domain
open System

//Pipeline functions
///Checks whether the command is one of (d)eposit, (w)ithdraw, or e(x)it.
let isValidCommand (command:char) = ['d'; 'w'; 'x'] |> List.contains command

///Checks whether the command is the e(x)it command.
let isStopCommand (command:char) = command = 'x'

///Returns a tuple of the command and the associated predefined value, or zero.
let getAmount (command:char) = 
    match command with
    | 'd' -> command, 50M
    | 'w' -> command, 25M
    | _ -> command, 0M

///Applies the given pair of command and amount to the account in question.
let processCommand (account:Account) (command:char, amount:decimal) = 
    match command with
    | 'd' -> deposit amount account
    | 'w' -> withdraw amount account
    | _ -> account

//Testing the pipeline
let openingAccount = {Owner = {Name = "Isaac"}; Balance = 0M; AccountId = Guid.Empty} //The test account
let account = 
    let commands = ['d'; 'w'; 'z'; 'f'; 'd'; 'x'; 'w']
    commands
    |> Seq.filter isValidCommand
    |> Seq.takeWhile (not << isStopCommand) //operator "<<" read as "compose left with" or "compose backwards from", in regards to the flow direction of output to input.
    |> Seq.map getAmount
    |> Seq.fold processCommand openingAccount

///Recreates an account information, based on it's transaction history and owner's personal information.
let loadAccount ownerName accountId (transactions:Transaction list) = 
    let account = { AccountId = accountId; Balance = 0M; Owner = { Name = ownerName } }
    transactions 
    |> List.sortBy (fun transaction -> transaction.Timestamp) 
    |> List.filter (fun transaction -> transaction.Accepted) //The only transactions that influence the balance are the accepted ones.
    |> List.fold 
        (fun acc transaction -> 
            let command = transaction.Operation.Chars(0)
            match command with
            | 'd' -> deposit transaction.Amount acc
            | 'w' -> withdraw transaction.Amount acc
            | _ -> acc
        ) 
        account
//Testing the loadAccount
let transactions = 
    [ { Timestamp = DateTime.Now; Operation = "deposit"; Amount = 50M; Accepted = false; Message = "test1" } 
      { Timestamp = DateTime.Now.AddDays(-1.0); Operation = "deposit"; Amount = 50M; Accepted = true; Message = "test1" } 
      { Timestamp = DateTime.Now; Operation = "withdraw"; Amount = 50M; Accepted = true; Message = "test2" } 
      { Timestamp = DateTime.Now.AddDays(-1.0); Operation = "withdraw"; Amount = 100M; Accepted = true; Message = "test3" } 
      { Timestamp = DateTime.Now.AddDays(-3.0); Operation = "deposit"; Amount = 50M; Accepted = true; Message = "test4" } ]

transactions
|> loadAccount "heron" Guid.Empty

let deserialize (text:string) = 
    if not (String.IsNullOrEmpty text) then
        let components = text.Split([|"***"|], System.StringSplitOptions.None)
//            text.Split('\n') //The only viable split for my case is on the new line character, which then isolates the message component of the transaction as it's own element...
//            |> Array.windowed 2 //... so I combine them in pairs. But the pairs in odd positions are uneeded, being a mixture of the previous message with the next header...
//            |> Array.mapi (fun index arr -> Array.filter (fun arr -> index % 2 = 0) arr) //... so I use mapi to give me the index on the external array, for use on the filter.
//            |> Array.filter (not << Array.isEmpty) //This eliminates the empty arrays generated by the results of mapi + filter.
//            |> Array.map (fun arr -> arr.[0] + arr.[1]) //The only way I found to concatenate the elements of the inner array together...
        { Timestamp = Convert.ToDateTime(components.[0]); Operation = components.[1]; Amount = decimal(components.[2]); Accepted = (components.[3] = "true"); Message = components.[4] }
    else
        failwith "Invalid string."

"17/05/2019 20:38:28***deposit***1231***false***
Performing a deposit operation for R$1231... Transaction not yet accepted.
17/05/2019 20:38:28***deposit***1231***true***
Transaction accepted! Balance is now R$1231.
17/05/2019 20:38:36***withdraw***999***false***
Performing a withdraw operation for R$999... Transaction not yet accepted.
17/05/2019 20:38:36***withdraw***999***true***
Transaction accepted! Balance is now R$232.
17/05/2019 20:38:43***deposit***281***false***
Performing a deposit operation for R$281... Transaction not yet accepted.
17/05/2019 20:38:43***deposit***281***true***
Transaction accepted! Balance is now R$513.
17/05/2019 20:38:47***withdraw***900***false***
Performing a withdraw operation for R$900... Transaction not yet accepted.
17/05/2019 20:38:47***withdraw***900***false***
Transaction rejected!
17/05/2019 20:38:51***withdraw***400***false***
Performing a withdraw operation for R$400... Transaction not yet accepted.
17/05/2019 20:38:51***withdraw***400***true***
Transaction accepted! Balance is now R$113.".Split('\n')
|> Array.windowed 2
|> Array.mapi (fun index arr -> Array.filter (fun arr -> index % 2 = 0) arr)
|> Array.filter (not << Array.isEmpty)
|> Array.map (fun arr -> arr.[0] + arr.[1])

"17/05/2019 20:38:51***withdraw***400***true***
Transaction accepted! Balance is now R$113.".Split([|"***"|], System.StringSplitOptions.None)

"17/05/2019 20:38:51***withdraw***400***true***
Transaction accepted! Balance is now R$113."
|> deserialize

//null |> deserialize
//"noeapodasopdopad" |> deserialize