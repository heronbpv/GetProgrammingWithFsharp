module Capstone3.FileRepository

open Capstone3.Domain
open System.IO
open System

let private accountsPath =
    let path = @"accounts"
    Directory.CreateDirectory path |> ignore
    path

let private findAccountFolder owner =    
    let folders = Directory.EnumerateDirectories(accountsPath, sprintf "%s_*" owner)
    if Seq.isEmpty folders then ""
    else
        let folder = Seq.head folders
        DirectoryInfo(folder).Name

let private buildPath(owner, accountId:Guid) = sprintf @"%s\%s_%O" accountsPath owner accountId

/// Logs to the file system
let writeTransaction accountId owner (transaction:Transaction) =
    let path = buildPath(owner, accountId)    
    path |> Directory.CreateDirectory |> ignore
    let filePath = sprintf "%s/%s.txt" path (owner + accountId.ToString())
    let serializedTransaction = Transactions.serialize transaction
    File.AppendAllText(filePath, serializedTransaction)

let findTransactionsOnDisk owner = 
    let path = findAccountFolder owner
    if String.IsNullOrEmpty path then
        Guid.Empty, Seq.empty
    else
        let accountId = 
            path.Split('_').[1] //The second string of the array always contains the account id
            |> Guid.Parse
        let transactions =             
            let text = File.ReadAllText(sprintf "%s/%s.txt" path (owner + accountId.ToString()))
            let entries = 
                text.Split('\n') //The only viable split for my case is on the new line character, which then isolates the message component of the transaction as it's own element...
                |> Array.windowed 2 //... so I combine them in pairs. But the pairs in odd positions are uneeded, being a mixture of the previous message with the next header...
                |> Array.mapi (fun index arr -> Array.filter (fun arr -> index % 2 = 0) arr) //... so I use mapi to give me the index on the external array, for use on the filter.
                |> Array.filter (not << Array.isEmpty) //But then a bunch of empty arrays are generated by the results of mapi + filter, so I need yet another one.
                |> Array.map (fun arr -> arr.[0] + arr.[1]) //And the only way I found to concatenate the elements of the inner array together, so...
            entries
            |> Array.map Transactions.deserialize
                
        accountId, (transactions |> Array.toSeq)